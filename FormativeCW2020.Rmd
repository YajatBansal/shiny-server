---
title: "Coursework for formative feedback"
author: "Yajat Bansal"
date: "12/11/20"
output:
  pdf_document: default
  df_print: paged
  html_notebook: default
  html_document:
    df_print: paged

---

Add to the code block below so that it generates from a distribution with pdf
\[
f_X(x) \propto  \mathrm{e}^{-x} (1+\sin(m x)), \quad x > 0,
\]
(where $m$ is a positive integer), using rejection sampling with an $Exponential(1)$ envelope, 
i.e. $g_Y(y) = \mathrm{e}^{-y}, \; y>0$.

Your output should be a data frame with n rows and column name "x". 
You can use runif, but no other inbuild R generators.

You should also add the mathematical justification for your method here in LaTeX, so that the notebook knits to a pdf file.  Make sure that you include code to load all relevant libraries.  You may want to add some additional plots to illustrate the pdf that you are simulating from and the envelope.

I will mark this piece of work out of 20, with 5 for exposition of the mathematical method, 5 for the R code, 5 for the diagnostics and 5 for presentation.

Please comment all code that is not obvious.

```{r}
library(ggplot2)
m = 10
fstar <- function(x, m=10) exp(-x) * (1 + sin(m*x))
g <- function(x) exp(-x) 
M <- 2
x = seq(0,3.5,l=100)
fgx = data.frame(x=x, fx=fstar(x,m), gx=M*g(x))
mylabs = list(expression(f[X](x)),expression(Mg[Y](x)))
p <- ggplot(fgx)
p + geom_line(aes(x,fx,colour="fx"))+
geom_line(aes(x,gx,colour="fy"))+
labs(y="pdf", title=bquote("Comparison of "~f[X](x)~"and "~Mg[X](x)~"where m=" ~ .(m))) + scale_colour_manual("", values=c("fx"="red","fy"="blue"), labels=mylabs)
```


```{r}
rds <- function(n, m){
 x <- vector("numeric",0)
 num <- 0
 M = 2/(1 + m/(m^2+1)) # in this case it is equivalent to 1/P(accept)
 x_len = 0 
 while(x_len <= n){
   n_gen = max(ceiling(M*(n-x_len)), 10) # optimising the number of vals we generate (no less than 10)
   u1 <- runif(n_gen)
   y <- -log(u1) # random Exp(1) variates generated by inversion
   u2 <- runif(n_gen)
   cond <- u2 <= 0.5*(1 + sin(m*y))
   x <- c(x, y[cond])
   x_len <- length(x)
}
 data.frame(x = x[1:n])
}
```

Below this line write some R code that produces at least 2 diagnostic plots that demonstrate the validity of your code for simulating from $f_X(x)$ and then use the R function ks.test to perform a  Kolmogorov-Smirnov test for some simulated data with varying values of n and m=1,5 and 10 (use ?ks.test for information about this test)

The first diagnostic plot we will look at is a histogram for the generateed values on which the true pdf is superimposed.
```{r}
# Histogram
library("ggplot2")
x_rds = rds(100, 10)
hist(x_rds$x, main = 'Theoretical vs Empirical Density', xlab = 'x', probability = TRUE)
curve(fstar, add = TRUE, col = 'red')
```

Lag Scatter Plots
```{r}
x_rds = rds(50,10)
```

```{r}
# K-S test 


```



```{r}
rds <- function(n, m){
  
 x <- vector("numeric",0)
 p <- vector("numeric",0)
 num <- 0
 M = 2/(1 + m/(m^2+1)) # in this case it is equivalent to 1/P(accept)
 x_len = 0 
 while(x_len <= n){
   n_gen = max(ceiling(M*(n-x_len)), 10) # optimising the number of vals we generate (no less than 10)
   u1 <- runif(n_gen)
   y <- -log(u1) # random Exp(1) variates generated by inversion
   u2 <- runif(n_gen)
   cond <- u2 <= 0.5*(1 + sin(m*y))
   x <- c(x, y[cond])
   p = c(p, sum(cond)/n_gen) # keeping track of probabilility each time
   x_len <- length(x)
}
 list(x = x[1:n], p = p)
}
```
